fin_map <- c()
parsed_names <- sapply(map[,2], function(x) strsplit(x, ' ', fixed = T))
Filtered_genes <- lapply(parsed_names, function(x){
if (length(x) >= 2){
x[2]
}else {
NA
}
})
Filtered_names <- lapply(parsed_names, function(x){
if(length(x) >= 1){
x[1]
}else{
NA
}
})
res3 <- as.data.frame(do.call(rbind, Filtered_names))
res3$V2 <- Filtered_genes
res3$well_name <- sapply(LETTERS[1:16], function(x) paste0(x, c(1:24))) %>% as.vector()
rownames(res3) <- res3[,3]
colnames(res3) <- c("Sample_name", "Gene_name")
return(map)
}
GetreactionNum <- function(file_name){
res <- read_xlsx(file_name, 1, range= "B42:Y57", col_names= F)%>% data.frame()
rownames(res) <- LETTERS[1:16] # rownames A-P
colnames(res) <- sapply(c(1:24), toString) #Plate columns 1-24
restrn<<- res
#Vector
map <- c()
for(row in c(1:16)){
#sub-setting
curRow <- unlist(res[row,])
#get info
well_id <- sapply(c(1:24), function(x) paste(LETTERS[row], toString(x), sep=''))
curRow <- cbind(well_id, curRow)
map <- rbind(map, curRow)
}
#parsing names
fin_map <- c()
parsed_names <- sapply(map[,2], function(x) strsplit(x, ' ', fixed=T))
parsed_names <- parsed_names[!is.na(parsed_names)]
#filtering the primers out of it
Filtered_genes <- lapply(parsed_names, function(x) {
if (length(x) >= 2) { # Check if the element has at least two values
x[2]  # No explicit return, R automatically returns the last expression
} else {
NA    # This is the last expression if the condition is false
}
})
res2 <- unlist(Filtered_genes)
restrn <<- res2
# Create a data frame with the original order of genes
gene_list <- data.frame(Gene = res2, stringsAsFactors = FALSE)
# Count the occurrences of each gene while preserving their original order
gene_list$Count <- ave(seq_along(gene_list$Gene), gene_list$Gene, FUN = length)
# Remove duplicates, keeping only the first appearance of each gene
gene_list <- gene_list[!duplicated(gene_list$Gene), ]
# Set row names and return the data frame
rownames(gene_list) <- gene_list$Gene
gene_list$Gene <- NULL
return(gene_list)
}
MMscheme <- function(R_num){
#first parameters Mastermix
sensi <- 1.5
FW <- 0.36
RV <- 0.36
Buff <- 0.5
MgCl2 <- 0.36
H2O <- 2.92
mastermix <- R_num
mastermix$ExcessReactions <- mastermix$Count + 15
mastermix$Sensimix <- mastermix$ExcessReactions * sensi
mastermix$FWprimer <- mastermix$ExcessReactions * FW
mastermix$RVprimer <- mastermix$ExcessReactions * RV
mastermix$buffer <- mastermix$ExcessReactions * Buff
mastermix$MgCl2 <- mastermix$ExcessReactions * MgCl2
mastermix$H2O <- mastermix$ExcessReactions * H2O
mastermix$Count <- NULL
mastermix$ExcessReactions <- NULL
mastermix$totalvol <- rowSums(mastermix)
# Rename rows and handle volume exceeding threshold
rownames(mastermix) <- paste("Mastermix", seq_len(nrow(mastermix)))
mastermix$Gene <- rownames(mastermix)
allmix <- split_larger_rows(mastermix)
allmix$totalvol <- NULL
return (allmix)
}
#Sollist
SolList_fill <- function(mastermix){
print(mastermix)
#time to generate the volume of the needed items
sensimixvol <- sum(mastermix$Sensimix)
buffervol <- sum(mastermix$buffer)
MgCl2vol <- sum(mastermix$MgCl2)
H2Ovol <- sum(mastermix$H2O)
track <- 0
if(H2Ovol > 1800){
H2Ovol <- H2Ovol/2
H2Ovol <- data.frame(H2Ovol)
H2Ovol <- rbind(H2Ovol, H2Ovol)
rownames(H2Ovol) <- paste("H2O", seq_len(nrow(H2Ovol)))
colnames(H2Ovol) <- c("ul")
track <- 1
}
print("wtf")
#firs aggregrate primers if they are for the same type of mmx
res <- data.frame(mastermix$FWprimer, mastermix$Gene)
print(res)
colnames(res) <- c("ul","gene")
print(res)
#group by gene (mmx) then rearrage that mmx 1 is top and next is mmx 2
res <- res %>% group_by(gene) %>%
summarise(
ul = sum(ul, na.rm = TRUE),
.groups = "drop"
)
print(res)
#and rearranging so that 10 is not earlier then 2
res <- res %>%   mutate(mm_num = as.numeric(sub(".*?(\\d+)$", "\\1", gene))) %>%
arrange(mm_num) %>%
select(-mm_num)
#now to recall it and make it about the primers
FWprimer <- data.frame(res$ul)
rownames(FWprimer) <- paste("Forward primer", seq_len(nrow(FWprimer)))
colnames(FWprimer) <- c("ul")
FWprimer[1] <- FWprimer[1] + 100
for (i in seq_len(nrow(FWprimer))){
if(FWprimer$ul[i] > 200){
FWprimer$ul[i] <- 200
}
}
Rvprimer <- data.frame(res$ul)
rownames(Rvprimer) <- paste("Reverse primer", seq_len(nrow(Rvprimer)))
colnames(Rvprimer) <- c("ul")
Rvprimer[1] <- Rvprimer[1] + 100
for (i in seq_len(nrow(Rvprimer))){
if(Rvprimer$ul[i] > 200){
Rvprimer$ul[i] <- 200
}
}
#complete the vollist to sollist for later assignment
vollist <- rbind(sensimixvol,buffervol,MgCl2vol,H2Ovol)
SolList <- data.frame(vollist)
colnames(SolList) <- c("ul")
if(track == 1){
rownames(SolList) <- c("sensimixvol", "buffervol", "MgCl2vol", rownames(H2Ovol))
}
colnames(SolList) <- c("ul")
SolList[1] <- SolList[1] + 100 #100 ul excess
SolList <- rbind(SolList, FWprimer, Rvprimer)
#add location in eppy
rows <- LETTERS[1:4]  # Rows A-D
cols <- 1:6           # Columns 1-6
slots <- c()
for (row in rows) {
slots <- c(slots, paste0(row, cols))
}
#formatting SolList for future Solution List
SolList$Slot_Id <- slots[seq_len(nrow(SolList))]
SolList$Deck_Id <- 4
SolList <- SolList %>% select(Slot_Id, everything())
SolList <- SolList %>% select(Deck_Id, everything())
na_index <- which(is.na(SolList$Slot_Id))
if (length(na_index) > 0){
SolList$Deck_Id[na_index:length(SolList$Deck_Id)] <- 5
reset_slots <- slots[seq_len(nrow(SolList) - na_index[1]+1)]
SolList$Slot_Id[na_index:nrow(SolList)] <- reset_slots[seq_along(na_index:nrow(SolList))]
}
return(SolList)
}
#Mainfunctions---------
main <- function(file_path, filename = ""){
# read excel
plateMap <- tryCatch({
GetPlateMap(file_path)
},
error = function(cond){
if(errMessage == ""){
errMessage <<- "Input file error - plateMap"
}
return(NA)
})
ReactionNum <- tryCatch({
GetreactionNum(file_path)
},
error = function(cond){
if(errMessage == ""){
errMessage <<- "Input file error - Gene names not correct"
}
return(NA)
})
Rnum <<- ReactionNum
#Calc MM components
Mastermix <- tryCatch({
MMscheme(ReactionNum)
},
error = function(cond){
if(errMessage == ""){
errMessage <<- "Mastermix could not be calculated"
}
return(NA)
})
print("here")
Mastermix <- Mastermix[order(as.numeric(sub(".*?(\\d+)$", "\\1", rownames(Mastermix)))), ]
mmx <<- Mastermix
#Sollist assignment
SolList <- tryCatch({
SolList_fill(Mastermix)
},
error = function(cond){
if(errMessage == ""){
errMessage <<- "Sollist could not be calculated"
}
return(NA)
})
sollist <<- SolList
#mastermix loc
rows <- LETTERS[1:4]  # Rows A-D
cols <- 1:6           # Columns 1-6
slots <- c()
for (row in rows) {
slots <- c(slots, paste0(row, cols))
}
if (errMessage==""){
last <- tail(SolList,1)
lastDeck_Id <- last$Deck_Id
lastSlot_Id <- last$Slot_Id
testlast <<- lastSlot_Id
testlastd <<- lastDeck_Id
idx <- match(lastSlot_Id, slots)
testidx <<- idx
if (idx == length(slots)){
#last slot was D6 therefore move to the next deck
lastDeck_Id <- lastDeck_Id +1
nextslots <- slots
}else{
#remaining slots in same deck
nextSlots <- nextSlots <- slots[(idx + 1):length(slots)]
}
#mastermix loc
n <- nrow(Mastermix)
slots_filled <- rep(NA_character_, n)
k <- min(length(nextSlots), n)
slots_filled[seq_len(k)] <- nextSlots[seq_len(k)]
Mastermix$Slot_Id <- slots_filled
Mastermix$Deck_Id <- lastDeck_Id
na_index <- which(is.na(SolList$Slot_Id))
test <<- na_index
if (length(na_index) > 0){
Mastermix$Deck_Id[na_index:length(Mastermix$Deck_Id)] <- 6
reset_slots <- slots[seq_len(nrow(Mastermix) - na_index[1]+1)]
Mastermix$Slot_Id[na_index:nrow(Mastermix)] <- reset_slots[seq_along(na_index:nrow(Mastermix))]
}
mmxloc <<- Mastermix
}
}
#TEST--------------
# input
errMessage <<- ""
fileName <- "qPCRTemplate384_PlateMap_128.xlsx"
#fileName <- "qPCRTemplate384_PlateMap.xlsx"
mainwd <- "C:\\Users\\jornb\\Documents\\GitHub\\ot2\\upstream (R) processors\\384qPCR"
input_file_name <- paste0(mainwd, "\\", fileName)
#
output <- main(input_file_name)
#write output
#write.csv(output[[1]], paste0(mainwd, "/Halving_CommandList.csv"), row.names=F)
#write_xlsx(output[[2]], paste0(mainwd, "/Halving_UserGuide.xlsx"))
View(mmxloc)
View(sollist)
View(mmxloc)
#META #####
#J. Brink Flex Controller -- 2026/02/11
# > 96 well plate for qPCR
# > Credits for S.T. Tandar for major help and contibutions
#Library ------------
library(shiny)
library(readxl)
library(writexl)
library(dplyr)
library(tidyr)
options(stringsAsFactors = F)
#Server Main functions-------------
shinyServer(function(input, output){
#first defining directorys --------- change if in troubleshooting or Servermode (not yet implemented)
# outputDir_cmdline <- "/home/shiny-ot2/ShinyApps/outputs_cmdlist"
# outputDir_usrGuide <- "/home/shiny-ot2/ShinyApps/outputs_usrguide"
# inputTemplate <- "/home/shiny-ot2/ShinyApps/ot2/qPCR/qPCR_template.xlsx"
# sourceDir <- "/home/shiny-ot2/ShinyApps/ot2/qPCR/96wellsplatefunctionqPCR.R"
#Troubleshooting (local machine paths)
outputDir_cmdline <- "C:\\Users\\jornb\\Documents\\GitHub\\ot2\\Execution code for OT2\\Incubator\\Test User inputs"
outputDir_usrGuide <- "C:\\Users\\jornb\\Documents\\GitHub\\ot2\\Execution code for OT2\\Incubator\\Test User inputs"
inputTemplate <- "C:\\Users\\jornb\\Documents\\GitHub\\ot2\\upstream (R) processors\\384qPCR\\qPCRTemplate384_PlateMap.xlsx"
sourceDir <- "C:\\Users\\jornb\\Documents\\GitHub\\ot2\\upstream (R) processors\\384qPCR\\384qPCR.R"
#Loading source
source(sourceDir)
#Initializing err message
errMessage <<- ""
#Obtain names---------
new_name <- reactive({
if(is.null(input$pmid)){pmid <- ''}else{pmid <- input$pmid}
if(is.null(input$exp_name)){expName <- ''}else{expName <- input$exp_name}
if(is.null(input$exp_num)){expNum <- ''}else{expNum <- input$exp_num}
if(is.null(input$f_name)){fName <- ''}else{fName <- input$f_name}
if(is.null(input$l_name)){lName <- ''}else{lName <- input$l_name}
#paste
res <- paste("PMID-", pmid, "_EXPID-",
expName, "-", expNum, "_", lName, ".", fName, sep='')
return(res)
})
#Confirming Upload File-----------
contents <- reactive({
infile = input$file
if(is.null(infile)){return(NULL)}
#perform if file is loaded
if(input$do==0){
dis <- read_xlsx(infile$datapath, sheet=1, range = "B57:M64", col_names=F)
pmap_output <<- dis
}else{
#rename files for safekeeping
file_name <<- strsplit(infile$name, '.xl')[[1]][1]
#update table view; perform main function note that dis is display
dis <- main(infile$datapath, infile$name)
if(errMessage==""){
#generate appropriate output files bit of a behind the scene for me cmdList_output is created by the << aka global good to know
#Robot Commands---------------
sel_colnames <- colnames(cmdList_output[[4]])
#initiate new command line output
new_cmdLineOutput <- c()
#add first item
nex_item <- replicate(length(sel_colnames), "")
nex_item[1] <- cmdList_output[[1]]
nex_item <- data.frame(t(nex_item))
colnames(nex_item) <- sel_colnames
new_cmdLineOutput <- rbind(new_cmdLineOutput, nex_item)
new_cmdLineOutput[] <- lapply(new_cmdLineOutput, as.character)
#add second item
cur_item <- cmdList_output[[2]]
cur_item[] <- lapply(cur_item, as.character)
new_item <- c()
for(j in c(1:length(cur_item[,1]))){
cur_itemRow <- cur_item[j,]
nex_item <- replicate(length(sel_colnames), "")
nex_item[1:length(cur_itemRow)] <- cur_itemRow
new_item <- rbind(new_item, nex_item)
}
colnames(new_item) <- c(sel_colnames)
new_item[] <- lapply(new_item, as.character)
new_cmdLineOutput <- rbind(new_cmdLineOutput, new_item)
#add third item
nex_item <- replicate(length(sel_colnames), "")
nex_item[1] <- cmdList_output[[3]]
nex_item <- data.frame(t(nex_item))
colnames(nex_item) <- sel_colnames
new_cmdLineOutput <- rbind(new_cmdLineOutput, nex_item)
#add fourth item
nex_item <- cmdList_output[[4]]
nex_item[] <- lapply(nex_item, as.character)
new_cmdLineOutput <- rbind.data.frame(new_cmdLineOutput, cmdList_output[[4]])
new_cmdLineOutput <- apply(new_cmdLineOutput,2,as.character)
#add fifth item
nex_item <- replicate(length(sel_colnames), "")
nex_item[1] <- cmdList_output[[5]]
nex_item <- data.frame(t(nex_item))
colnames(nex_item) <- sel_colnames
new_cmdLineOutput <- rbind(new_cmdLineOutput, nex_item)
#add sixth item
nex <- cmdList_output[[6]]
colnames(nex) <- colnames(new_cmdLineOutput)
new_cmdLineOutput <- rbind.data.frame(new_cmdLineOutput, nex, stringsAsFactors = F)
#place to global
new_cmdLineOutput[new_cmdLineOutput == "NA"] <- ""
new_cmdLineOutput <<- new_cmdLineOutput
#User Commands---------------
sel_colnames <- colnames(usercmd_output[[2]])
#initiate new command line output
new_userGuideOutput <- c()
#add first item--------------
nex_item <- replicate(length(sel_colnames), "")
nex_item[1] <- '>>> Stocklist <<<'
nex_item <- data.frame(t(nex_item))
colnames(nex_item) <- sel_colnames
new_userGuideOutput <- rbind(new_userGuideOutput, nex_item)
#add second item
first_item <- c()
curItem <- usercmd_output[[1]]
for(i in 1:nrow(curItem)){
curRow <- curItem[i,]
nex_item <- replicate(length(sel_colnames), "")
nex_item[1:length(curRow)] <- curRow
first_item <- rbind(first_item, nex_item)
}
colnames(first_item) <- sel_colnames
new_userGuideOutput <- rbind.data.frame(new_userGuideOutput, first_item)
#Third part
nex_item <- replicate(length(sel_colnames), "")
nex_item[1] <- '>>> Empty tubes <<<'
nex_item <- data.frame(t(nex_item))
colnames(nex_item) <- sel_colnames
new_userGuideOutput <- rbind(new_userGuideOutput, nex_item)
#add fourth item
first_item <- c()
curItem <- usercmd_output[[2]]
for(i in 1:nrow(curItem)){
curRow <- curItem[i,]
nex_item <- replicate(length(sel_colnames), "")
nex_item[1:length(curRow)] <- curRow
first_item <- rbind(first_item, nex_item)
}
colnames(first_item) <- sel_colnames
new_userGuideOutput <- rbind.data.frame(new_userGuideOutput, first_item)
#fifth part
nex_item <- replicate(length(sel_colnames), "")
nex_item[1] <- '>>> Samples <<<'
nex_item <- data.frame(t(nex_item))
colnames(nex_item) <- sel_colnames
new_userGuideOutput <- rbind(new_userGuideOutput, nex_item)
#add 6th item
first_item <- c()
curItem <- usercmd_output[[3]]
for(i in 1:nrow(curItem)){
curRow <- curItem[i,]
nex_item <- replicate(length(sel_colnames), "")
nex_item[1:length(curRow)] <- curRow
first_item <- rbind(first_item, nex_item)
}
colnames(first_item) <- sel_colnames
new_userGuideOutput <- rbind.data.frame(new_userGuideOutput, first_item)
#lastpart of Rhandler
FLEXdeck <- cmdList_output[[6]]
FLEXdeck <- FLEXdeck[c(2)]
FLEXdeck <- unlist(FLEXdeck)
matrixversion <- matrix(FLEXdeck, nrow=4, ncol=3, byrow = TRUE)
res3 <- as.data.frame(matrixversion)
colnames(res3) <- c("[,1]", "[,2]", "[,3]")
#Finally
nex_item <- replicate(length(sel_colnames), "")
nex_item[1] <- '>>> FLEX DECK <<<'
nex_item <- data.frame(t(nex_item))
colnames(nex_item) <- sel_colnames
titlenex <- nex_item
first_item <- c()
curItem <- res3
for(i in 1:nrow(curItem)){
curRow <- curItem[i,]
nex_item <- replicate(length(sel_colnames), "")
nex_item[1:length(curRow)] <- curRow
first_item <- rbind(first_item, nex_item)
}
colnames(first_item) <- sel_colnames
new_userGuideOutput <- rbind.data.frame(first_item, new_userGuideOutput)
new_userGuideOutput <- rbind.data.frame(nex_item, new_userGuideOutput)
new_userGuideOutput <- apply(new_userGuideOutput,2,as.character) %>% data.frame()
new_userGuideOutput <<- new_userGuideOutput
#savekeeping output files
#command line
cmdLine_name <- paste("CommandList_", new_name(), '.csv', sep='')
write_dir <- paste(outputDir_cmdline, cmdLine_name, sep='/')
write.csv(new_cmdLineOutput, write_dir, row.names = FALSE)
#user guide
usrGuide_name <- paste("RobotHandler_", new_name(), '.xlsx', sep='')
write_dir <- paste(outputDir_usrGuide, usrGuide_name, sep='/')
write_xlsx(new_userGuideOutput, write_dir, col_names=T)
}
}
return(dis)
})
output$tab <- renderTable({contents()})
#Enabling download button-------
output$downloadData <- renderUI({
req(input$do, contents())
downloadButton("d_OT2", "Download Robot Commands")
})
output$downloadData2 <- renderUI({
req(input$do, contents())
downloadButton("guide", "Download Robot Setup Guide")
})
output$downloadData3 <- renderUI({
req(input$do, contents())
downloadButton("plateMap", "Download Plate Map")
})
#Sample File Name--------
output$tex <- renderText({new_name()})
#Defining download buttons--------
output$d_OT2 <- downloadHandler(
filename = function(){paste("CommandList_", new_name(), '.csv', sep='')},
content = function(file) {
write.csv(new_cmdLineOutput, file, row.names = FALSE)
}
)
output$guide <- downloadHandler(
filename = function(){paste("RobotHandler_", new_name(), '.xlsx', sep='')},
content = function(file) {
write_xlsx(new_userGuideOutput, file, col_names=T)
#write.csv(new_userGuideOutput, file, row.names = FALSE)
}
)
#download input template
output$downloadTemplate <- downloadHandler(
filename = "qPCR_InputTemplate.xlsx",
content = function(file) {
file.copy(inputTemplate, file)
}
)
})
runApp('GitHub/ot2/upstream (R) processors/384qPCR')
runApp('GitHub/ot2/upstream (R) processors/384qPCR')
runApp('GitHub/ot2/upstream (R) processors/384qPCR')
View(sollist)
runApp('GitHub/ot2/upstream (R) processors/384qPCR')
